(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?module.exports=factory():typeof define==="function"&&define.amd?define(factory):global.magic=factory()})(this,function(){"use strict";const resolve=async value=>{value=await value;if(Array.isArray(value)){return await Promise.all(value.map(resolve))}return await value};const reject=message=>Promise.reject(new Error(message));const regexpCallback=cb=>cb instanceof RegExp?cb.test.bind(cb):cb;const extend=(cb,self)=>async(value,i,all)=>({value:value,extra:await regexpCallback(cb).call(self,value,i,all)});const extraUp=({extra:extra})=>extra;const valueUp=({value:value})=>value;const extendArray={filter:(obj,cb,self)=>resolve(obj.map(extend(cb,self))).then(arr=>arr.filter(extraUp).map(valueUp))};const getter=obj=>(target,key)=>{if(key==="then")return(...args)=>{return resolve(obj).then(...args)};if(key==="catch")return(...args)=>{return root(resolve(obj).catch(...args))};return func(resolve(obj).then(obj=>{if(typeof key==="symbol")return obj[key];for(let k in extendArray){if(Array.isArray(obj)&&key===k){return func((cb,self)=>extendArray[k](obj,cb,self))}}if(obj[key]&&obj[key].bind){return func(obj[key].bind(obj))}return func(obj[key])}))};const applier=obj=>(target,self,args)=>{return func(resolve(obj).then(obj=>{if(typeof obj!=="function"){return reject(`\n        You tried to call the non-function "${JSON.stringify(obj)}" (${typeof obj}).\n        This can happen in several situations like these:\n        - await magic(['a'])();  // <= wrong\n        - await magic(['a']).map(a => a)(a => a);  // <= wrong\n      `)}return obj(...args)}))};const root=obj=>new Proxy({},{get:getter(obj)});const func=obj=>new Proxy(()=>{},{get:getter(obj),apply:applier(obj)});return root});