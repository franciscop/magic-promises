(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?module.exports=factory():typeof define==="function"&&define.amd?define(factory):global.magic=factory()})(this,function(){"use strict";const log=()=>{};const resolve=async value=>{value=await value;if(Array.isArray(value)){return await Promise.all(value.map(resolve))}return await value};const reject=message=>Promise.reject(new Error(message));const getter=obj=>(target,key)=>{if(key==="then")return(...args)=>{log("GETTER THEN",obj,...args);return resolve(obj).then(...args)};if(key==="catch")return(...args)=>{log("GETTER CATCH",obj,...args);return root(resolve(obj).catch(...args))};return func(resolve(obj).then(obj=>{if(typeof key==="symbol")return obj[key];if(obj[key]&&obj[key].bind){return func(obj[key].bind(obj))}return func(obj[key])}))};const applier=obj=>(target,self,args)=>{return func(resolve(obj).then(obj=>{if(typeof obj!=="function"){return reject(`\n        You tried to call the non-function "${JSON.stringify(obj)}" (${typeof obj}).\n        This can happen in several situations like these:\n        - await magic(['a'])();  // <= wrong\n        - await magic(['a']).map(a => a)(a => a);  // <= wrong\n      `)}return obj(...args)}))};const root=obj=>new Proxy({},{get:getter(obj)});const func=obj=>new Proxy(()=>{},{get:getter(obj),apply:applier(obj)});return root});